// /*
//     Generated by cib for ABI compatibility and stability.
// // */

// #pragma once

// #include "__zz_cib_Module-type-converter-base.h"

// #include "__zz_cib_Module-class-types.h"

// namespace __zz_cib_ {

// template <typename T>
// class __zz_cib_CoreTypeToAbiType<T, std::enable_if_t<__zz_cib_IsValueClass_v<T>>>
// {
//   T m;

// public:
//   T Convert()
//   {
//     return std::move(m);
//   }

// public:
//   __zz_cib_CoreTypeToAbiType(T x)
//     : m(std::move(x))
//   {
//   }

//   operator T()
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_CoreTypeToAbiType<T*,
//                                  std::enable_if_t<__zz_cib_IsValueClass_v<__zz_cib_RemoveAllDecorations_t<T>>>>
// {
//   T* m;

// public:
//   T* Convert()
//   {
//     return m;
//   }

// public:
//   __zz_cib_CoreTypeToAbiType(T* x)
//     : m(x)
//   {
//   }

//   operator T*()
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_CoreTypeToAbiType<T&,
//                                  std::enable_if_t<__zz_cib_IsValueClass_v<__zz_cib_RemoveAllDecorations_t<T>>>>
// {
//   T& m;

// public:
//   T* Convert()
//   {
//     return &m;
//   }

// public:
//   __zz_cib_CoreTypeToAbiType(T& x)
//     : m(x)
//   {
//   }

//   operator T*()
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_CoreTypeToAbiType<T&&, std::enable_if_t<__zz_cib_IsValueClass_v<T>>>
// {
//   T m;

// public:
//   T* Convert()
//   {
//     return &m;
//   }

// public:
//   __zz_cib_CoreTypeToAbiType(T&& x)
//     : m(x)
//   {
//   }

//   operator T*()
//   {
//     return Convert();
//   }
// };

// template <typename T, int N>
// class __zz_cib_CoreTypeToAbiType<T[N],
//                                  std::enable_if_t<__zz_cib_IsValueClass_v<__zz_cib_RemoveAllDecorations_t<T>>>>
// {
//   T* m;

// public:
//   T* Convert()
//   {
//     return m;
//   }

// public:
//   __zz_cib_CoreTypeToAbiType(T x[N])
//     : m(x)
//   {
//   }

//   operator T*() const
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_CoreTypeToAbiType<T[],
//                                  std::enable_if_t<__zz_cib_IsValueClass_v<__zz_cib_RemoveAllDecorations_t<T>>>>
// {
//   T* m;

// public:
//   T* Convert()
//   {
//     return m;
//   }

// public:
//   __zz_cib_CoreTypeToAbiType(T x[])
//     : m(x)
//   {
//   }

//   operator T*() const
//   {
//     return Convert();
//   }
// };

// /////////////////////////////////////////////////////////////////////////////////////////////

// template <typename T>
// class __zz_cib_AbiTypeToCoreType<T, std::enable_if_t<__zz_cib_IsValueClass_v<T>>>
// {
//   __zz_cib_AbiType_t<T> m;

// public:
//   __zz_cib_AbiTypeToCoreType(__zz_cib_AbiType_t<T> x)
//     : m(x)
//   {
//   }

//   T Convert() const
//   {
//     return m;
//   }

//   operator T() const
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_AbiTypeToCoreType<T*,
//                                  std::enable_if_t<__zz_cib_IsValueClass_v<__zz_cib_RemoveAllDecorations_t<T>>>>
// {
//   static_assert(std::is_same_v<T*, __zz_cib_AbiType_t<T*>>);

//   T* m;

// public:
//   __zz_cib_AbiTypeToCoreType(T* x)
//     : m(x)
//   {
//   }

//   T& Convert()
//   {
//     return *m;
//   }

//   operator T&()
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_AbiTypeToCoreType<T&,
//                                  std::enable_if_t<__zz_cib_IsValueClass_v<__zz_cib_RemoveAllDecorations_t<T>>>>
// {
//   static_assert(std::is_same_v<T*, __zz_cib_AbiType_t<T&>>);

//   T* m;

// public:
//   __zz_cib_AbiTypeToCoreType(T* x)
//     : m(x)
//   {
//   }

//   T& Convert()
//   {
//     return *m;
//   }

//   operator T&()
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_AbiTypeToCoreType<T&&,
//                                  std::enable_if_t<__zz_cib_IsValueClass_v<__zz_cib_RemoveAllDecorations_t<T>>>>
// {
//   static_assert(std::is_same_v<T*, __zz_cib_AbiType_t<T&&>>);

//   T* m;

// public:
//   __zz_cib_AbiTypeToCoreType(T* x)
//     : m(x)
//   {
//   }

//   T&& Convert()
//   {
//     return std::move(*m);
//   }

//   operator T &&()
//   {
//     return Convert();
//   }
// };

// template <typename T, int N>
// class __zz_cib_AbiTypeToCoreType<T[N], std::enable_if_t<__zz_cib_IsValueClass_v<T>>>
// {
//   T* m;

// public:
//   T* Convert() const
//   {
//     return m;
//   }

// public:
//   __zz_cib_AbiTypeToCoreType(T* x)
//     : m(x)
//   {
//   }

//   operator T*() const
//   {
//     return Convert();
//   }
// };

// template <typename T>
// class __zz_cib_AbiTypeToCoreType<T[], std::enable_if_t<__zz_cib_IsValueClass_v<T>>>
// {
//   T* m;

// public:
//   T* Convert() const
//   {
//     return m;
//   }

// public:
//   __zz_cib_AbiTypeToCoreType(T* x)
//     : m(x)
//   {
//   }

//   operator T*() const
//   {
//     return Convert();
//   }
// };

// } // namespace __zz_cib_
